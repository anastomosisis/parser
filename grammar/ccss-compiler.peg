{
  var p, parser, flatten, _varsCache, _measuresCache; 

  p = parser = this;

  p.commands = [];  

  p.cs = [];
  p.addC = function (c) {
    p.commands.push(c);
  };
  
  p.$s = [];
  p.add$ = function ($) {
    if (p.$s.indexOf($) === -1) {p.$s.push($);}
    return $;
  }

  _varsCache = [];
  p.vars = [];
  p.addVar = function (ast,id) {
    if (_varsCache.indexOf(id) === -1) {
      _varsCache.push(id);
      p.commands.push(ast);
    }
    return ast;
  }
  
  _measuresCache = [];
  p.measures = [];
  p.processMeasure = function (ast) {
    var _id;
    _id = ast.toString(); // assuming stringified ast arrays CAN be used for cache lookup
    if (_measuresCache.indexOf(_id) === -1) {
      _measuresCache.push(_id);
      p.measures.push(ast);
    }
    return ast;
  }

  p.getResults = function () {
    return {
      "selectors": p.$s,
      "commands": p.commands
      //"measures": p.measures,
      //"vars": p.vars,
      //"constraints": p.cs      
    }
  }
  
  p.toString = function (x) {
    if (typeof x === "string") {return x}
    if (x instanceof Array) {return x.join("")}
    return ""
  }

  p.error = function (m,l,c) {
    if (!!l && !!c) {m = m+ " {line:" + l + ", col:" + c + "}"} 
    console.error(m);
    return m;
  }

}

start
  = __ statements:(Statement*) __ { return (parser.getResults()); }

Statement
  = exp:LinearExpression EOS __ { return exp; }
  / stay:Stay                 { return stay; }

Stay 
  =  StayStart vars:StayVars+ EOS __ {
      var stay = ["stay"].concat(vars)
      parser.addC(stay)
      return stay;
    }

StayVars
  = __ v:Var __ ","?  {return v}

StayStart
  = ("@-gss-stay" / "@stay")

LinearExpression
  = e1:AdditiveExpression
    tail:(__ EqOperator __ AdditiveExpression)*
    __ s:StrengthAndWeight? {
      var eq, e2;
      if (s.length === 0) {s = [];}
      for (var i = 0; i < tail.length; i++) {
        eq = tail[i][1];
        e2 = tail[i][3];
        parser.addC([
          eq,
          e1,
          e2
        ].concat(s));
        e1 = e2;
      }
      return "LineaerExpression";
    }

StrengthAndWeight
  = "!" s:Strength w:Weight?  {
      if (w.length === 0) {return [s];}
      return [s,w];
    }
  / "!" .? {return parser.error("Invalid Strength or Weight",line,column)}

Weight
  = w:[0-9]+   {return Number(w.join(""))}

Strength
  = ("require"  / "REQUIRE"  / "Require")  {return "require"}
  / ("strong"   / "STRONG"   / "Strong")   {return "strong"}
  / ("medium"   / "MEDIUM"   / "Medium")   {return "medium"}
  / ("weak"     / "WEAK"     / "Weak")     {return "weak"}
  / ("required" / "REQUIRED" / "Required") {return "require"}

EqOperator
  = "==" { return "eq" }
  / "<=" { return "lte" }
  / ">=" { return "gte" }
  / "<"  { return "lt"  }
  / ">"  { return "gt"  }

AdditiveExpression
  = head:MultiplicativeExpression
    tail:(__ AdditiveOperator __ MultiplicativeExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = [
          tail[i][1],
          result,
          tail[i][3]
        ];
      }
      return result;
    }

AdditiveOperator
  = "+" { return "plus" }
  / "-" { return "minus" }

MultiplicativeExpression
  = head:UnaryExpression
    tail:(__ MultiplicativeOperator __ UnaryExpression)* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = [
          tail[i][1],
          result,
          tail[i][3]
        ];
      }
      return result;
    }

MultiplicativeOperator
  = "*" {return "multiply"}
  / "/" {return "divide"}

UnaryExpression
  = PrimaryExpression
  / operator:UnaryOperator __ expression:UnaryExpression {
      return {
        type:       "UnaryExpression",
        operator:   operator,
        expression: expression
      };
    }

UnaryOperator
  = "+"
  / "-"
  /  "!"

PrimaryExpression
  = Measure
  / Var 
  / Literal
  / "(" __ expression:LinearExpression __ ")" { return expression; }

Measure "measure"
  = "measure(" __ v:Var __ ")"  { return p.processMeasure(["measure",v]);}

Var "variable"
  = $:Selector? "[" v:NameChars+ "]" {       
      var result, id, _id1, _id2;
      v = v.join("");      
      // if bound to dom query
      if ($.length !== 0) {
        parser.add$($.selector);
        // normalize var names when query bound
        if (v === 'left') {
          v = 'x';
        } else if (v === 'top') {
          v = 'y';
        } else if (v === 'cx') {
          v = 'center-x';
        } else if (v === 'cy') {
          v = 'center-y';
        }
        // normalize window var names
        if ($.selector === '::window') {
          if (v === 'right') {
            v = 'width'
          } else if (v === 'bottom') {
            v = 'height'
          }
        }
        id = "["+v+"]";
        id = $.selector + id;
        // extract variable expresssions
        switch (v) {            
          case 'right':
            _id1 = $.selector + "[" + "x" + "]";
            _id2 = $.selector + "[" + "width" + "]";
            parser.addVar(['var', _id1, "x", $.ast], _id1);
            parser.addVar(['var', _id2, "width", $.ast], _id2);
            parser.addVar(['varexp',id,['plus',['get',_id1],['get',_id2]], $.ast], id);
            break;
          case 'bottom':
            _id1 = $.selector + "[" + "y" + "]";
            _id2 = $.selector + "[" + "height" + "]";
            parser.addVar(['var', _id1, "y", $.ast], _id1);
            parser.addVar(['var', _id2, "height", $.ast], _id2);
            parser.addVar(['varexp',id,['plus',['get',_id1],['get',_id2]], $.ast], id);
            break;
          case 'center-x':          
          case 'centerX':
            _id1 = $.selector + "[" + "x" + "]";
            _id2 = $.selector + "[" + "width" + "]";
            parser.addVar(['var', _id1, "x", $.ast], _id1);
            parser.addVar(['var', _id2, "width", $.ast], _id2);
            parser.addVar(['varexp',id,['plus',['get',_id1],['divide',['get',_id2],2]], $.ast], id);                       break;
          case 'center-y':
          case 'centerY':
            _id1 = $.selector + "[" + "y" + "]";
            _id2 = $.selector + "[" + "height" + "]";
            parser.addVar(['var', _id1, "y", $.ast], _id1);
            parser.addVar(['var', _id2, "height", $.ast], _id2);
            parser.addVar(['varexp',id,['plus',['get',_id1],['divide',['get',_id2],2]], $.ast], id);                       break;
          default:
            parser.addVar(['var',id,v,$.ast],id);
        }
        // add constraints for window x & y to be zero
        /*if ($.selector === '::window') {
          if (v === 'x' || v === 'center-x') {
            parser.addC([
              'eq',
              ['get', '::window[x]'],
              ['number', 0],
              'required'
            ]);
          } else if (v === 'y' || v === 'center-y') {
            parser.addC([
              'eq',
              ['get', '::window[y]'],
              ['number', 0],
              'required'
            ]);
          }
        }*/
      }
      else {
        id = "["+v+"]";
        parser.addVar(['var',id],id);
        // ['_dimensionize',['get','width'],['get','height']]
      }
      if ($.selector) {
        return ['get',id,$.selector];
      } else {
        return ['get',id];
      }
      
    }

VarNames
  = ""  
  // "position"  {return ["x","y"]}
  // "size"  {return ["width","height"]}


Selector "selector"
  = "#" $:NameChars+  { $=p.toString($); return {selector:"#"+$,ast:["$id",$]} }
  / "." $:NameChars+  { $=p.toString($); return {selector:"."+$,ast:["$class",$]} }
  / "$(" $:QuerySelectorChars+ ")"  { $=p.toString($); return {selector:$,ast:["$all",$]} }
  / $:NameChars+  { $=p.toString($); return {selector:$,ast:["$tag",$]} }  
  / "::" $:ReservedPseudos {return {selector:"::"+$,ast:["$reserved", $]}}
  // $:QuerySelectorChars+ { $=p.toString($); return {selector:$,ast:["$all",$]} }

QuerySelectorChars
  = [a-zA-Z0-9#.\-_$=:+>'" \]\[]
  


ReservedPseudos
  = ("this" / "document" / "host")
  / ("window" / "viewport") {return "window"} 
  // normalize viewport to window

  //$:(pre:NameChars* "[" attr:NameCharsWithSpace+ "]")  { $=p.toString($); return {selector:$,ast:["$all",$]} }


  

NameChars
  = [a-zA-Z0-9#.\-_$]

NameCharsWithSpace
  = NameChars / " "

Literal
  = val:(Real / Integer) {
    return [ "number",
      val
    ]
  }

Integer
  = digits:[0-9]+ {
    return parseInt(digits.join(""));
  }

Real
  = digits:(Integer "." Integer) {
    return parseFloat(digits.join(""));
  }

SignedInteger
  = [-+]? [0-9]+

SourceCharacter
  = .

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator

EOS
  = __ ";"
  / _ LineTerminatorSequence
  / __ EOF

EOF
  = !.

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

MultiLineCommentNoLineTerminator
  = "/*" (!("*/" / LineTerminator) SourceCharacter)* "*/"

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)* (LineTerminator / EOF)
_
  = (WhiteSpace / MultiLineCommentNoLineTerminator / SingleLineComment)*

__
  = (WhiteSpace / LineTerminatorSequence / Comment)*
