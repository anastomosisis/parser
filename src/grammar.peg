{
  var p = this;
  var g = (function() {
    var getLineNumber = function() {
      return line();
    };

    var getColumnNumber = function() {
      return column();
    };

    var getErrorType = function() {
      return SyntaxError;
    };

    var Grammar = require('./grammar');

    return new Grammar(p, getLineNumber, getColumnNumber, getErrorType);
  })();
}

start 
  = __ s:Statements __ { return s; }

Statements
  = __ commandObjects:(Statement*) {return g.mergeCommands(commandObjects);}

Statement
  = __ s:StatementTypes EOS __ { return s; }

StatementTypes
  = ConstraintStatement
  / InlineConstraintStatement
  / InlineSet
  / Ruleset
  / Virtual
  / IfElseStatement
  / Stay
  / Chain
  / ForEach
  / Directive


IfElseStatement "IfElseStatement"
  = i:If es:ElseChain+
    {return {commands:[i.concat(es)]};}
  / i:If
    {return {commands:[i]};}


ElseChain
  = __ e:Else {return e;}

If
  = "@if" _ test:Expression __ "{" __ s:Statements __ "}"
    {return ["if",test,s.commands];}
  / "@if" [^{]* __ "{" __ s:Statements __ "}"
    {throw new g._Error('Invalid If Clause', null, null, null, g._lineNumber(), g._columnNumber());}

Else
  = "@else" _ test:Expression? __ "{" __ s:Statements __ "}"
    {return [test || true,s.commands];}
  / "@else" [^{]* __ "{" __ s:Statements __ "}"
    {throw new g._Error('Invalid Else Clause', null, null, null, g._lineNumber(), g._columnNumber());}

ConstraintStatement "ConstraintStatement"
  = head:ConstraintAdditiveExpression
    tail:(__ ConstraintOperator __ ConstraintAdditiveExpression)* __ strengthAndWeight:StrengthAndWeight? {
      return g.constraint(head, tail, strengthAndWeight);
    }

InlineConstraintStatement "InlineConstraintStatement"
  = __ prop:[^:)(\]\[@ ]+ _ ":" _ op:ConstraintOperator rest:[^;]+ &";" {
      return g.inlineConstraint(prop,op,rest);
    }

InlineSet "Inline Set"
  = __ prop:[^:)(\]\[@ ]+ _ ":" rest:[^;]+ &";" {
      return g.inlineSet(prop,rest);
    }

Ruleset
  = q:CSSSelector __ "{" __ s:Statements __ "}"
    {return {commands:[['rule',q,s.commands]]}}

Directive "Directive"
  = "@" name:[^ {}]+ terms:[^{};]+ "{" __ s:Statements __ "}"
    {return g.directive(name.join(''),terms.join('').trim(),s.commands);}
  / "@" name:[^ {}]+ terms:[^;]+ &";"
    {return g.directive(name.join(''),terms.join('').trim());}


Expression
  = AndOrExpression

AndOrExpression
  = head:DualOperatorExpression tail:(__ AndOrOp __ DualOperatorExpression)* {
    return g.nestedDualTermCommands(head, tail);
  }

AndOrOp
  = ("AND" / "and" / "And" / "&&") { return '&&'; }
  / ("OR"  / "or"  / "Or"  / "||") { return '||'; }

DualOperatorExpression
  = head:AdditiveExpression tail:(__ DualOperator __ AdditiveExpression)* {
      return g.nestedDualTermCommands(head, tail);
    }

DualOperator
  = ConstraintOperator
  / "!="          { return "!="; }
  / "="           { return "="; }
  / "~="          { return "~="; }

ConstraintOperator "Constraint Operator"
  = "=="          { return "==";  }
  / ("<=" / "=<") { return "<="; }
  / (">=" / "=>") { return ">="; }
  / "<"           { return "<";  }
  / ">"           { return ">";  }

ConstraintAdditiveExpression
  = head:ConstraintMultiplicativeExpression
    tail:(__ AdditiveOperator __ ConstraintMultiplicativeExpression)* {
      return g.nestedDualTermCommands(head, tail);
    }

AdditiveExpression
  = head:MultiplicativeExpression
    tail:(__ AdditiveOperator __ MultiplicativeExpression)* {
      return g.nestedDualTermCommands(head, tail);
    }

AdditiveOperator
  = "+" { return "+";  }
  / "-" { return "-"; }

ConstraintMultiplicativeExpression
  = head:ConstraintPrimaryExpression
    tail:(__ MultiplicativeOperator __ ConstraintPrimaryExpression)* {
      return g.nestedDualTermCommands(head, tail);
    }

MultiplicativeExpression
  = head:PrimaryExpression
    tail:(__ MultiplicativeOperator __ PrimaryExpression)* {
      return g.nestedDualTermCommands(head, tail);
    }

MultiplicativeOperator
  = "*" { return '*'; }
  / "/" { return '/';   }

ConstraintPrimaryExpression
  = Var
  / Literal
  / "(" __ expression:ConstraintAdditiveExpression __ ")" {
    return expression;
  }

PrimaryExpression
  = Var
  / Literal
  / String
  / "true"        {return true;}
  / "false"       {return false;}
  / "null"        {return null;}
  / "undefined"   {return undefined;}
  / "(" __ expression:Expression __ ")" { return expression; }

Var "variable"
  = negative:'-'? selector:GSSSelector? "[" variableNameCharacters:NameChars+ "]" {
      return g.variable(negative, selector, variableNameCharacters);
    }

String
  = ["'] string:([^"'])* ["'] {return string.join('');}   //"

NameChars
  = [a-zA-Z0-9#.\-_$]

NameCharsWithSpace
  = NameChars / " "

Literal
  = val:Numeric u:Unit { return [u, val]; }
  / val:Numeric        { return val; }

Unit
  = "px" / "em" / "vh" / "vh" / "%" / "rem"  / "ex" / "ch" / "vmin" / "vmax"
  / "cm" / "mm" / "in" / "pt" / "pc"

Numeric
  = Real / Integer / SignedReal / SignedInteger

Integer
  = digits:[0-9]+ { return g.integer(digits); }

SignedInteger
  = sign:[-+] integer:Integer? { return g.signedInteger(sign, integer); }

Real
  = left:[0-9]* "." right:[0-9]+ { return parseFloat(left.join('') + "." + right.join('')); }

SignedReal
  = sign:[-+] real:Real { return g.signedReal(sign, real); }

SourceCharacter
  = .

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator

EOS
  = __ ";"
  / _ LineTerminatorSequence
  / __ EOF

EOF
  = !.

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "/*" (!"*/" SourceCharacter)* "*/"

MultiLineCommentNoLineTerminator
  = "/*" (!("*/" / LineTerminator) SourceCharacter)* "*/"

SingleLineComment
  = "//" (!LineTerminator SourceCharacter)* (LineTerminator / EOF)
_
  = (WhiteSpace / MultiLineCommentNoLineTerminator / SingleLineComment)*

__
  = (WhiteSpace / LineTerminatorSequence / Comment)*



// Query Selectors
// ===================================================

GSSSelector
  = ctx:NoParanSelectorChain sel:SafeCSSSelector {return [ctx, sel] }
  / SafeCSSSelector
  / left:SimpleSelectorChain _ {return left;}

SafeCSSSelector 
  = "(" __ sel:CSSSelector __ ")" {return sel;}

CSSSelector
  = head:ComplexSelectorChain tail:( __ "," __ ComplexSelectorChain )+
    { return g.createSelectorCommaCommand(head, tail); }
  / ComplexSelectorChain

ComplexSelectorChain
  = filters:ComplexSelector+  { return g.reverseFilterNest(filters);}

SimpleSelectorChain
  = filters:SimpleSelector+  { return g.reverseFilterNest(filters);}

NoParanSelectorChain
  = filters:NoParanSelector+  { return g.reverseFilterNest(filters);}

NoParanSelector "NoParanSelector"
  = VirtualSel / TagSel / IdSel / ClassSel / ReservedSel / PseudoSel

SimpleSelector "SimpleSelector"
  = NoParanSelector
  / SafeCSSSelector

Qualifier
  = SimpleSelector
  / AttrSel

ComplexSelector
  = Qualifier
  / c:Combinator              {return [c]}

Combinator "Combinator"
  = _ c:[><+~!]+ _           {return c.join('');}
  // TODO: &[^... used for rulesets & other stuff...
  / " "+ &[^{,)]                     {return " "}

VirtualSel
  = ["] o:SplattedName ["]
    {
      return g.splatExpander('$virtual',o);
    }
  / ["] id:[^"]+ ["]
    {return ["$virtual",id.join("")];}

SplattedName
  = splats:Splat+ postfix:SplatNameChar* 
    {
      return {splats:splats,postfix:postfix.join("")};
    }

Splat "Splat"
  = prefix:SplatNameChar+ o:Range 
    {
       o.prefix = prefix.join("");       
       return o;
     }

Range "Range"
  = from:[0-9]+ "..." to:[0-9]+ 
    {
      from = Number(from.join(''));
      to   = Number(to.join(''));
      return {from:from,to:to}
    }

SplatNameChar
  = !Range char:SelectorNameChars {return char}

TagSel
  = name:SelectorName         {return ["$tag",name];}
  / "*"                       {return ["$tag", "*"];}

IdSel
  = "#" name:(SplattedName / SelectorName)
    {return g.splatifyIfNeeded('$id',name);}

ClassSel
  = "." name:(SplattedName / SelectorName)
    {return g.splatifyIfNeeded('$class',name);}

ReservedSel
  = name:ReservedPseudos  {return [name];}
  / "$"                   {return ["$"];}               // global scope selector
  / "&" &[^&]             {return ["&"];}               // this scope selector
  / ups:"^"+              {return [ups.join('')];}      // parent scope selector
  

ReservedPseudos
  = ("::document" / "::host" / "::scope" / "::parent")
  / ("::window" / "::viewport") { return "::window"; }
  / ("::this" / "::") { return "&"; }

PseudoSel
  = ("::" / ":") name:SelectorName option:PseudoSelOption? {
    if (option) {return ["$pseudo",name,option];}
    return ["$pseudo",name];
  }

PseudoSelOption
  = "(" option:[^)]* ")"       {return option.join(""); }

AttrSel
  = "[" left:[^~|=!\^$&\*\]]+ op:[~|=!^$&*]+ right:[^\]]+ "]"        {return ["$attribute",op.join(""),left.join("").trim(),right.join("").trim()]; }
  / "[" attr:[^\]]+ "]"        {return ["$attribute",attr.join("")]; }


SelectorName
  = name:SelectorNameChars+    {return name.join("")}

SelectorNameChars
  = [a-zA-Z0-9\-_]





// Strength & Weight
// ===================================================

StrengthAndWeight "Strength and Weight"
  = "!" strength:Strength weight:Weight?  {
    return g.strengthAndWeight().valid(strength, weight);
  }
  / "!" .? {
    return g.strengthAndWeight().invalid();
  }

Weight
  = weight:[0-9]+ { return Number(weight.join('')); }

Strength
  = ("required" / "REQUIRED" / "Required") { return "require"; }
  / ("require"  / "REQUIRE"  / "Require")  { return "require"; }
  / ("strong"   / "STRONG"   / "Strong")   { return "strong"; }
  / ("medium"   / "MEDIUM"   / "Medium")   { return "medium"; }
  / ("weak"     / "WEAK"     / "Weak")     { return "weak"; }
  / strength:[a-zA-Z\-_]+                   { return strength.join('').toLowerCase(); }


// Virtual
// ===================================================
// also see query selectors

Virtual
  = "@" ("-gss-virtual" / "virtual") __ names:VirtualName+ {
    return g.virtualElement(names);
  }

VirtualName
  = '"' name:[^"]+ '"' __ {
    return name.join('');
  }


// Stays
// ===================================================

Stay
  =  StayStart variables:StayVars+ {
      return g.stay(variables);
    }

StayVars
  = __ variable:Var __ ","?  { return g.stayVariable(variable); }

StayStart
  = ("@-gss-stay" / "@stay")




// JS hooks
// ===================================================

ForEach
  = type:ForLooperType __ selector:GSSSelector __ javaScript:JavaScript {
    return g.forEach(type, selector, javaScript)
  }

JavaScript
  = "```" characters:[^`]* "```" { return g.javaScript(characters); }

ForLooperType
  = ("@-gss-for-each" / "@for-each") { return g.forLoopType().forEach(); }
  / ("@-gss-for-all" / "@for-all") { return g.forLoopType().forAll(); }



// Chains
// ===================================================

Chain
  = "@" "-gss-"? "chain" __ selector:GSSSelector __ chainers:Chainer+ __ { //sw:StrengthAndWeight?
    return g.chain(selector, chainers);
  }

Chainer
  = headCharacters:[a-zA-Z\-_0-9]+ "(" _
    headExpression:HeadExp? _
    headOperator:ChainEq _
    bridgeValue:BridgeValue? _
    tailOperator:ChainEq? _
    strengthAndWeight:StrengthAndWeight? _ ")"
    tailCharacters:[a-zA-Z\-_0-9]* __ {
      return g.chainer({
        headCharacters: headCharacters,
        headExpression: headExpression,
        headOperator: headOperator,
        bridgeValue: bridgeValue,
        tailOperator: tailOperator,
        strengthAndWeight: strengthAndWeight,
        tailCharacters: tailCharacters
      });
    }

HeadExp
  = operator:ChainMath expression:AdditiveExpression {
    return g.headExpression(operator, expression);
  }

TailExp
  = expression:AdditiveExpression operator:ChainMath {
    return g.tailExpression(expression, operator);
  }

ChainMath
  = "+" { return g.chainMathOperator().plus(); }
  / "-" { return g.chainMathOperator().minus(); }
  / "*" { return g.chainMathOperator().multiply(); }
  / "/" { return g.chainMathOperator().divide(); }

ChainEq
  = operator:ConstraintOperator? {
    return g.chainConstraintOperator(operator);
  }

BridgeValue
  = (AdditiveExpression)
